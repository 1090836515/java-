package OperatingSystem;

/**
 * 1，在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行时，该进程就被迫让出CPU，该进程便由执行状态转变为就绪状态。
 *        运行——>就绪：1，主要是进程占用CPU的时间过长，时间片用完；（）
 *        就绪——>运行：运行的进程的时间片用完，调度就转到就绪队列中选择合适的进程分配CPU
 *        运行——>阻塞：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如发生了I/O请求
 *        阻塞——>就绪: 进程所等待的事件已经发生，就进入就绪队列
 * 2.就绪状态和阻塞状态都分为活动态和静止态。由活动态向静止态转换就是通过挂起实现的，如果进程处在挂起状态，则进程暂不接受调度
 * 3.线程的生命周期：线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 READY（就绪） 状态。可运行状态的线程获得
 *      了 CPU 时间片（timeslice）后就处于 RUNNING（运行） 状态。 当线程执行 wait()方法之后，线程进入 WAITING（等待） 状态。进入等待状态的
 *      线程需要依靠其他线程的通知才能够返回到运行状态，而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过
 *      sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回
 *      到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。线程在执行 Runnable 的run()方法
 *      之后将会进入到 TERMINATED（终止） 状态。
 */
public class 进程状态切换 {
}
