package 数据库;

/**
 * 1.MySQL存储的基础知识：
 *      （1）Mysql的基本存储结构是页(记录都存在页里边)，各个数据页可以组成一个双向链表，而每个数据页中的记录又可以组成一个单向链表
 *      （2）每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后
 *              再遍历该槽对应分组中的记录即可快速找到指定的记录。以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。
 *      （3）InnoDB 存储引擎使用页作为数据读取单位，页是其磁盘管理的最小单位，默认 page 大小是 16k。系统的一个磁盘块的存储空间往往没有这么大，
 *              因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。在查询数据时如果一个页中的每条数据都能助于定位数据
 *              记录的位置，这将会减少磁盘 I/O 的次数，提高查询效率。
 * 1.B+树：
 *      （1）有n棵子树的非叶子结点中含有n个关键字（b树是n-1个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（b树是每个关键字
 *              都保存数据）。
 *      （2）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接（叶子节点组成
 *              一个双向链表）。
 *      （3）所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。
 *      （4）通常在b+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。
 *      （5）而在B+树中，顺序检索比较明显，从叶子节点从头到尾遍历，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找
 *              路径长度相同，导致每一个关键字的查询效率相当，时间复杂度为O(logN)
 *      (6)B+树的磁盘读写代价更低。B+树的内部结点并没有指向关键字具体信息的指针，只有关键字信息的索引，其内部结点比B树小，盘块能容纳的结点中关键字
 *              数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素。
 * 2.B树：
 *       B树中关键字集合分布在整棵树中,每个节点中有key，也有data，而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点(即一个盘块)能
 *          存储的 key 的数量很小。
 * 2.B+树相比于B树的优点(二叉查找树、平衡二叉树(AVL 树)、平衡多路查找树(B-Tree))：
 *     （1）考虑磁盘IO的影响，它相对于内存来说是很慢的。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐
 *          一加载每一个磁盘页（对应索引树的节点）。所以我们要减少IO次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一，
 *          m的大小取决于磁盘页的大小。
 *     （2）不同于B树只适合随机检索，B+树同时支持随机检索和顺序检索；
 *     （3）B+树的磁盘读写代价更低。B+树的内部结点并没有指向关键字具体信息的指针，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入
 *              内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素。
 *     （4）B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，
 *              其性能等价于在关键字全集内做一次二分查找，查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)。而在B+树中，顺序检索比较明显，
 *              随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当，为logN。
 *     （5）增删文件(节点)时，效率更高，因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率，双向链表
 *              (数据库索引采用B+树的主要原因是，)B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接
 *              在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作(或者说效率太低)。
 * 4.索引的最左匹配原则：如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否存在（相等），遇到范围查询
 *      (>、<、between、like左匹配)等就不能进一步匹配了，后续退化为线性查找。如有索引 (a,b,c,d)，查询条件
 *      select * from user where name=xx and city=xx ; ／／可以命中索引
 *      select * from user where name=xx ; // 可以命中索引
 *      select * from user where city=xx ; // 无法命中索引
 * 5.=、in自动优化顺序：不需要考虑=、in等的顺序，mysql会自动优化这些条件的顺序，以匹配尽可能多的索引列。
 * 如有索引 (a,b,c,d)，查询条件 c>3 and b=2 and a=1 and d<4与 a=1 and c>3 and b=2 and d<4等顺序都是可以的，MySQL会自动
 *      优化为a=1 and b=2 and c>3 and d<4，依次命中a、b、c。
 * 6.索引总结：
 *      1.索引失效：(1)条件中有or;(2)索引列参与（函数）计算如 where age + 10 = 30;(3)like以%开头(LIKE '%后盾');(4)如果列类型是字符串，
 *          则一定要在条件使用引号引起来（如where 'a' = 1不走索引）（5） where子句中使用!=或<>操作符（6）where子句中对字段进行 null值判断
 *          （where num is null)（6）where子句中使用参数（where num=@num）
 *      2.适合建立索引注意事项：（1）并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利
 *          用索引，如一表中有字段 sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。（2）索引并不是越多越好，索引固然
 *          可以提高相应的 select的效率，但同时也降低了 insert及 update的效率，因为 insert或 update时有可能会重建索引，所以怎样建索引需要
 *          慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。（3）应尽可能的避免更新
 *          clustered索引数据列，因为 clustered索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相
 *          当大的资源。若应用系统需要频繁更新 clustered索引数据列，那么需要考虑是否应将该索引建为 clustered索引。（4）尽量使用数字型字段，若
 *          只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每
 *          一个字符，而对于数字型而言只需要比较一次就够了。（5）任何地方都不要使用 select * from t，用具体的字段列表代替“*”，不要返回用不到的
 *          任何字段。（5）避免使用子查询，可以把子查询优化为 join 操作通常子查询在 in 子句中，子查询的结果集无法使用索引，通常子查询的结果集
 *          会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。
 *      3.InnoDB只有通过索引条件检索数据才使用行级锁，否则，InnoDB将使用表锁
 * 7.主键默认会建唯一索引，跟主键组合的索引会成为聚集索引INDEX (c2,c3)，CREATE INDEX index_name ON table_name (column_list)。
 *      默认情况下，如果未指定索引类型，MySQL将创建B-Tree索引
 * 8.聚集索引与非聚集索引：聚集索引就是数据行的物理顺序与列值逻辑顺序相同（以主键创建的索引），非聚集索引就是物理顺序与逻辑顺序不同（以非
 *       主键创建的索引）。
 *       InnoDB聚集索引的叶子节点存储行记录，因此InnoDB必须要有且只有一个聚集索引。这种机制使得基于PK的查询速度非常快，因为直接定位的行记录。
 *           1.如果表定义了PK（Primary Key，主键），那么PK就是聚集索引。
 *           2.如果表没有定义PK，则第一个NOT NULL UNIQUE的列就是聚集索引。
 *           3.否则InnoDB会另外创建一个隐藏的ROWID作为聚集索引。
 *       InnoDB普通索引的叶子节点存储主键值（MyISAM则是存储的行记录头指针）
 *           聚集索引在叶子节点存储的是表中的数据；
 *           非聚集索引在叶子节点存储的是主键和索引列；
 *           使用非聚集索引查询出数据时，拿到叶子上的主键再去查到想要查找的数据。
 *           创建多个单列(非聚集)索引的时候，会生成多个索引树。
 * 9.回表：普通索引因为无法直接定位行记录，其查询过程在通常情况下是需要扫描两遍索引树的。第一遍先通过普通索引定位到主键值，然后第二遍再通过
 *      聚集索引定位到具体行记录。这就是所谓的回表查询，性能相对于只扫描一遍聚集索引树的性能要低一些。
 * 10.索引覆盖：是一种避免回表查询的优化策略。具体的做法就是将要查询的数据作为索引列建立普通索引（可以是单列索引，也可以一个索引语句定义
 *      所有要查询的列，即联合索引），这样的话就可以直接返回索引中的的数据，不需要再通过聚集索引去定位行记录，避免了回表的情况发生。如果
 *      一个索引覆盖（包含）了所有需要查询的字段的值，这个索引就是覆盖索引。
 * 11.      1.添加PRIMARY KEY（主键索引）
 *      ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` )
 *          2.添加UNIQUE(唯一索引)
 *      ALTER TABLE `table_name` ADD UNIQUE ( `column` )
 *          3.添加INDEX(普通索引)
 *      ALTER TABLE `table_name` ADD INDEX index_name ( `column` )
 *          4.添加FULLTEXT(全文索引)
 *      ALTER TABLE `table_name` ADD FULLTEXT ( `column`)
 *          5.添加多列索引
 *      ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )
 * 12.MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）,InnoDB 存储引擎在分布式事务的情况下一般会用到
 *      SERIALIZABLE(可串行化) 隔离级别。
 * 13.explain命令：explain后边跟着SQL语句可以学习到该条SQL是如何执行的，其中包含:
 *      (1)id:包含一组数字，表示查询中执行SELECT子句或操作表的顺序。如果id相同执行顺序由上至下。如果id不相同，id的序号会递增，id值越大优先级越高，
 *          越先被执行。(一般有子查询的SQL语句id就会不同)
 *      (2)select_type:SIMPLLE：简单查询，该查询不包含 UNION 或子查询;PRIMARY：如果查询包含UNION 或子查询，则最外层的查询被标识为PRIMARY;
 *              SUBQUERY：子查询中的第一个select语句(该子查询不在from子句中);DERIVED：包含在from子句中子查询(也称为派生表)
 *      (3)table:该列显示了对应行正在访问哪个表(有别名就显示别名)。
 *      (4)type:ALL：全表扫描，这个类型是性能最差的查询之一;index：全索引扫描，和 ALL 类型类似，只不过 ALL 类型是全表扫描，而 index 类型是
 *              扫描全部的索引，主要优点是避免了排序，但是开销仍然非常大。如果在 Extra 列看到 Using index，说明正在使用覆盖索引，只扫描索引
 *              的数据，它比按索引次序全表扫描的开销要少很多;range：范围扫描，就是一个有限制的索引扫描，它开始于索引里的某一点，返回匹配这个值
 *              域的行;ref：一种索引访问，也称索引查找，它返回所有匹配某个单个值的行。此类型通常出现在多表的 join 查询, 针对于非唯一或非主键
 *              索引, 或者是使用了最左前缀规则索引的查询;eq_ref：使用这种索引查找，最多只返回一条符合条件的记录。在使用唯一性索引或主键查找时
 *              会出现该值，非常高效;const、system：该表至多有一个匹配行，在查询开始时读取，或者该表是系统表，只有一行匹配。其中 const 用
 *              于在和 primary key 或 unique 索引中有固定值比较的情形。
 *       (5)possible_keys:这一列显示查询可能使用哪些索引来查找
 *       (6)keys:这一列显示MySQL实际决定使用的索引。如果没有选择索引，键是NULL。
 *       (7)ref:这一列显示了哪些字段或者常量被用来和key配合从表中查询记录出来。
 *       (8)rows:这一列显示了估计要找到所需的行而要读取的行数，这个值是个估计值，原则上值越小越好。
 *       (9)extra:其他信息；Using index：使用覆盖索引，表示查询索引就可查到所需数据，不用扫描表数据文件，往往说明性能不错；Using Where：在存
 *              储引擎检索行后再进行过滤，使用了where从句来限制哪些行将与下一张表匹配或者是返回给用户；Using temporary：在查询结果排序时会
 *              使用一个临时表，一般出现于排序、分组和多表 join 的情况，查询效率不高，建议优化；Using filesort：对结果使用一个外部索引排序，
 *              而不是按索引次序从表里读取行，一般有出现该值，都建议优化去掉，因为这样的查询 CPU 资源消耗大
 */
public class MySQL索引 {
}
