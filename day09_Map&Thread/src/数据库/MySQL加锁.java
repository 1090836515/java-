package 数据库;

/**
 * 1.对于UPDATE、DELETE、INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；MyISAM在执行查询语句 SELECT前，会自动给涉及的所有表
 *      加读锁，在执行更新操作（ UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预。
 * 2.InnoDB只有通过索引条件检索数据才使用行级锁，否则，InnoDB将使用表锁
 * 3.在表读锁和表写锁的环境下：读读不阻塞，读写阻塞，写写阻塞！
 * 4.MyISAM可以支持查询和插入操作的并发进行；MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。但是InnoDB存储引擎是不支持的！
 *      如果某个进程想要获取读锁，同时另外一个进程想要获取写锁。在mysql里边，写锁是优先于读锁的！
 * 5.InnoDB实现了以下两种类型的行锁。
 *      共享锁（S锁）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
 *          也叫做读锁：读锁是共享的，多个客户可以同时读取同一个资源，但不允许其他客户修改。
 *      排他锁（X锁)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。
 *          也叫做写锁：写锁是排他的，写锁会阻塞其他的写锁和读锁。
 * 6.数据库的乐观锁与悲观锁：
 *      乐观锁其实是一种思想，正如其名：认为不会锁定的情况下去更新数据，如果发现不对劲，才不更新(回滚)。在数据库中往往添加一个version
 *          字段来实现。
 *      悲观锁用的就是数据库的行锁，认为数据库会发生并发冲突，直接上来就把数据锁住，其他事务不能修改，直至提交了当前事务。
 * 7.避免死锁：
 *      1）以固定的顺序访问表和行。比如对两个job批量更新的情形，简单方法是对id列表先排序，后执行，这样就避免了交叉等待锁的情形；将两个
 *          事务的sql顺序调整为一致，也能避免死锁。
 *      2）大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。
 *      3）在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。
 *      4）降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。
 *      5）为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。
 */
public class MySQL加锁 {
}
