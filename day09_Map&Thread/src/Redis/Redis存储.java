package Redis;

import java.util.*;

/**
 * 1.为什么要用redis而不用map做缓存?
 *      Java实现的Map是本地缓存，如果有多台实例(机器)的话，每个实例都需要各自保存一份缓存，缓存不具有一致性
 *      Redis实现的是分布式缓存，如果有多台实例(机器)的话，每个实例都共享一份缓存，缓存具有一致性。
 *      Java实现的Map不是专业做缓存的，JVM内存太大容易挂掉的。一般用做于容器来存储临时数据，缓存的数据随着JVM销毁而结束。
 *      Redis是专业做缓存的，可以用几十个G内存来做缓存。Redis一般用作于缓存，可以将缓存数据保存在硬盘中，Redis重启了后可以将其恢复。
 * 2.为什么要用缓存（redis被广泛应用于缓存）？
 *      高性能：缓存查询速度比数据库要快得多（内存VS硬盘）
 *      高并发：缓存分担部分请求，支持更高的并发
 * 3.Redis对象的一些细节：
 *      (1：服务器在执行某些命令的时候，会先检查给定的键的类型能否执行指定的命令。比如我们的数据结构是sortset，但你使用了list的命令。
 *      (2：Redis的对象系统带有引用计数实现的内存回收机制。对象不再被使用的时候，对象所占用的内存会释放掉
 *      (3：Redis会共享值为0到9999的字符串对象
 *      (4：对象会记录自己的最后一次被访问时间，这个时间可以用于计算对象的空转时间
 * 4.Redis持久化：Redis 是单线程程序，这个线程要同时负责多个客户端套接字的并发读写操作和内存数据结构的逻辑读写。
 *      (1)RDB:通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服
 *      务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。Redis
 *      默认采用的持久化方式.SAVE会阻塞Redis服务器进程，服务器不能接收任何请求，直到RDB文件创建完毕为止;BGSAVE创建出一个子进程，由子进程
 *      来负责创建RDB文件，服务器进程可以继续接收请求。
 *      RDB的优点：载入时恢复数据快、文件体积小。RDB的缺点：会一定程度上丢失数据(因为系统一旦在定时持久化之前出现宕机现象
 *      AOF的优点：丢失数据少(默认配置只丢失一秒的数据)。AOF的缺点：恢复数据相对较慢，文件体积大
 *      (2)AOF:保存Redis服务器所执行的写命令.与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。开启AOF持久化后每执行
 *      一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件,AOF文件的保存位置和RDB文件的位置相同.
 * 5.Redis事务：multi开启事务，exec执行事务
 * 6.缓存雪崩：Redis挂掉了，请求全部走数据库。对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。
 *      解决方法：在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期（参考）。
 * 7.缓存穿透：是指查询一个一定不存在的数据。由于缓存不命中，并且出于容错考虑，如果从数据库查不到数据则不写入缓存，这将导致这个不存在的数据
 *      每次请求都要到数据库去查询，失去了缓存的意义。
 *      解决办法：当我们从数据库找不到的时候，也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里获取，一般会将空对象设置一个
 *          较短的过期时间。
 * 8.如何保证数据库与缓存数据的一致性？：将删除缓存（数据不一致不需要更新，直接删除效果更好，等再次读取时，缓存里没有，那我到数据库找，在数据
 *      库找到再写到缓存里边(体现懒加载)）、修改数据库、读取缓存等的操作积压到队列里边，实现串行化,但这样效率会很低
 * 9.什么时候会想到用redis:
 *      1.查询速度要求高的时候，Redis存在内存里，读写速度大大快于存在硬盘里的Mysql;
 *      2.当数据多、并发量大的时候，架构中可以引入Redis，帮助提升架构的整体性能，减少Mysql(或其他数据库)的压力，但不是使用Redis，
 *          就不用MySQL。但对有复杂逻辑关系的存储不适合。
 *      3.经常会被查询，但是不经常被修改或者删除的数据；比如数据字典，业务数据中的热点数据；这样不仅提升查询效率，还可以减少数据库的压力；
 *      4.Redis主要是用作缓存，在数据不频繁修改的时候就不需要经常更新缓存，也就没有数据不一致的问题，同时查询速度快，就比较适合了
 * 10.哨兵模式：哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，
 *      等待Redis服务器响应，从而监控运行的多个Redis实例。
 *      哨兵的作用：（1）通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器；（2）当哨兵监测到master宕机，会自动将slave
 *          切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。然而一个哨兵进程对Redis服务器进行监控，可能会
 *          出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。
 *      故障切换（failover）：假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，
 *          这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，
 *          进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。
 */
public class Redis存储 {
    public static void main(String[] args) {
    }
    class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x) {
            this.val = x;
        }
    }
}
