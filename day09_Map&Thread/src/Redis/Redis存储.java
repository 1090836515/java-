package Redis;

import java.util.*;

/**
 * 1.为什么要用redis而不用map做缓存?
 *      Java实现的Map是本地缓存，如果有多台实例(机器)的话，每个实例都需要各自保存一份缓存，缓存不具有一致性
 *      Redis实现的是分布式缓存，如果有多台实例(机器)的话，每个实例都共享一份缓存，缓存具有一致性。
 *      Java实现的Map不是专业做缓存的，JVM内存太大容易挂掉的。一般用做于容器来存储临时数据，缓存的数据随着JVM销毁而结束。
 *      Redis是专业做缓存的，可以用几十个G内存来做缓存。Redis一般用作于缓存，可以将缓存数据保存在硬盘中，Redis重启了后可以将其恢复。
 * 2.为什么要用缓存（redis被广泛应用于缓存）？
 *      高性能：缓存查询速度比数据库要快得多（内存VS硬盘）
 *      高并发：缓存分担部分请求，支持更高的并发
 * 3.Redis主从同步：Redis主从复制可以根据是否是全量分为全量同步和增量同步。
 *      （1）全量同步
 * 　　       Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下： 
 * 　　       1）从服务器连接主服务器，发送SYNC命令； 
 * 　　       2）主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； 
 * 　　       3）主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； 
 * 　　       4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； 
 * 　　       5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； 
 * 　　       6）从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；
 *          完成上面几个步骤后就完成了从服务器数据初始化的所有操作，从服务器此时可以接收来自用户的读请求。
 *     （2）增量同步
 * 　    　Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。 
 *        增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。
 *     （3）Redis主从同步策略
 * 　　   主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，
 *          无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。
 * 4.Redis持久化：Redis 是单线程程序，这个线程要同时负责多个客户端套接字的并发读写操作和内存数据结构的逻辑读写。
 *      (1)RDB:通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服
 *      务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。Redis
 *      默认采用的持久化方式.SAVE会阻塞Redis服务器进程，服务器不能接收任何请求，直到RDB文件创建完毕为止;BGSAVE创建出一个子进程，由子进程
 *      来负责创建RDB文件，服务器进程可以继续接收请求。
 *      RDB的优点：载入时恢复数据快、文件体积小。RDB的缺点：会一定程度上丢失数据(因为系统一旦在定时持久化之前出现宕机现象
 *      AOF的优点：丢失数据少(默认配置只丢失一秒的数据)。AOF的缺点：恢复数据相对较慢，文件体积大
 *      (2)AOF:保存Redis服务器所执行的写命令.与快照持久化相比，AOF持久化的实时性更好，因此已成为主流的持久化方案。开启AOF持久化后每执行
 *      一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件,AOF文件的保存位置和RDB文件的位置相同.
 * 5.Redis事务：multi开启事务，exec执行事务
 * 6.缓存雪崩：Redis挂掉了，请求全部走数据库。对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。
 *      解决方法：在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期（参考）。
 * 7.缓存穿透：是指查询一个一定不存在的数据。由于缓存不命中，并且出于容错考虑，如果从数据库查不到数据则不写入缓存，这将导致这个不存在的数据
 *      每次请求都要到数据库去查询，失去了缓存的意义。
 *      解决办法：当我们从数据库找不到的时候，也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里获取，一般会将空对象设置一个
 *          较短的过期时间。
 * 8.如何保证数据库与缓存数据的一致性？：将删除缓存（数据不一致不需要更新，直接删除效果更好，等再次读取时，缓存里没有，那我到数据库找，在数据
 *      库找到再写到缓存里边(体现懒加载)）、修改数据库、读取缓存等的操作积压到队列里边，实现串行化,但这样效率会很低
 * 9.什么时候会想到用redis:
 *      1.查询速度要求高的时候，Redis存在内存里，读写速度大大快于存在硬盘里的Mysql;
 *      2.当数据多、并发量大的时候，架构中可以引入Redis，帮助提升架构的整体性能，减少Mysql(或其他数据库)的压力，但不是使用Redis，
 *          就不用MySQL。但对有复杂逻辑关系的存储不适合。
 *      3.经常会被查询，但是不经常被修改或者删除的数据；比如数据字典，业务数据中的热点数据；这样不仅提升查询效率，还可以减少数据库的压力；
 *      4.Redis主要是用作缓存，在数据不频繁修改的时候就不需要经常更新缓存，也就没有数据不一致的问题，同时查询速度快，就比较适合了
 * 10.哨兵模式：哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，
 *      等待Redis服务器响应，从而监控运行的多个Redis实例。
 *      哨兵的作用：（1）通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器；（2）当哨兵监测到master宕机，会自动将slave
 *          切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。然而一个哨兵进程对Redis服务器进行监控，可能会
 *          出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。
 *      故障切换（failover）：假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，
 *          这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，
 *          进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。
 * 11.Redis过期键的删除策略：（1）被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key；（2）主动删除：由于惰性删除策略
 *      无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批已过期的key；（3）当前已用内存超过maxmemory限定时，触发主动清理策略
 *      （1）被动删除：
 *              1、这种删除策略对CPU是友好的，删除操作只有在不得不的情况下才会进行，不会对其他的expire key上浪费无谓的CPU时间。
 *              2、但是这种策略对内存不友好，一个key已经过期，但是在它被操作之前不会被删除，仍然占据内存空间。如果有大量的过期键存在但是又很少被访问到，
 *              那会造成大量的内存空间浪费。
 *      （2）当REDIS运行在主从模式时，只有主结点才会执行上述这两种过期删除策略，然后把删除操作”del key”同步到从结点
 *      （3）当前已用内存超过maxmemory限定时，触发主动清理策略，注意这个清理过程是阻塞的，直到清理出足够的内存空间。所以如果在达到maxmemory并且
 *          调用方还在不断写入的情况下，可能会反复触发主动清理策略，导致请求会有一定的延迟；这里提一句，实际上redis根本就不会准确的将整个数据库中
 *          最久未被使用的键删除，而是每次从数据库中随机取5个键并删除这5个键里最久未被使用的键。
 */
public class Redis存储 {
    public static void main(String[] args) {
    }
    class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x) {
            this.val = x;
        }
    }
}
