package JVM;

/**
 * 1.垃圾回收算法：
 *      （1）标记清除：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象；缺点：会产生大量不连续的碎片，分配不了大对象，效率低。
 *      （2）复制算法：将内存分为两块，每次使用其中的一块，将不需要回收的对象复制到另一块，然后将原来的区域全部回收；效率高但可使用内存变小。
 *      （3）标记整理算法：标记过程仍然与“标记-清除”算法一样，然后将所有存活的对象往一端移动，然后清理掉边界外的所有对象。
 *      （4）分代收集算法：这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，
 *          这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，
 *          只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，
 *          所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。
 * 2.垃圾回收机制回收任何对象之前，会先调用对象的 finalize() 方法
 * 3.分代收集算法：将堆分为新生代，老年代；新生代又分为Eden,from,to区，默认8：1：1，新创建的对象都会被分配到Eden区（大对象直接进入到老年代），
 *      在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。Eden区满时进行MinorGC（复制算法），
 *      Java对象大多数都具备朝生夕死的特性，所以Minor GC非常频繁，一般回收速度比较快。Eden区中所有存活的对象都会被复制到“To”，
 *      而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。
 *      经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会进行交换。Minor GC会一直重复这样的过程，直到“To”区被填满,
 *      “To”区被填满之后,会将所有对象移动到年老代中,老年代满了会触发FullGC(标记清除/整理算法)。
 * 4.垃圾收集器：（1）串行收集器：在垃圾收集的时候必须暂停其他所有线程，直到收集结束。（2）多线程收集器：多线程版本收集器，除了使用多线程进行
 *      垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。（3）Parallel Scavenge 收集器：也是使用复制算法
 *      的多线程收集器，它看上去几乎和ParNew都一样，关注点是吞吐量（高效率的利用 CPU）（4）CMS 收集器：是一种以获取最短回收停顿时间为目标的
 *      收集器。它非常符合在注重用户体验的应用上使用，是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程
 *      （基本上）同时工作。（5）G1 收集器：是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时
 *      间要求的同时,还具备高吞吐量性能特征.
 *             新生代采用复制算法，老年代采用标记-整理算法。
 */
public class JVM垃圾回收 {
}
