package JVM;

/**
 * 1.内存划分：线程私有：程序计数器，虚拟机栈，本地方法栈；线程共享：堆，方法区，
 *      （1）程序计数器：实现代码的流程控制，记录线程执行的状态，线程切换的时候能继续执行
 *      （2）虚拟机栈：Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分，
 *          Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。存放基本数据类型及对象的引用
 *      （3）本地方法栈：与虚拟机栈类似，区别是为本地方法服务，本地方法保存在动态连接库中，格式是各个平台专用的，非Java代码的接口
 *      （4）堆：存放对象的实例，数组；垃圾回收的主要区域，可以细分为新生代老年代
 *      （5）方法区：存放已被虚拟机加载的类信息、常量、静态变量，也叫永久代
 *      （6）运行时常量池：JDK1.7时在方法区中，1.8之后在堆中；Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息
 *         （用于存放编译期生成的各种字面量和符号引用）
 * 2.String s1 = new String("abc");这句话创建了几个字符串对象？
 *     将创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，
 *     那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。
 *     String str1 = "abcd";//先检查字符串常量池中有没有"abcd"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，
 *     如果有，则直接将 str1 指向"abcd""；String str3 = "str" + "ing";//常量池中的对象
 *     String str2 = new String("abcd");//堆中创建一个新的对象；String str4 = str1 + str2; //在堆上创建的新的对象
 * 3.类的加载过程：加载（获取二进制字节流，生成Class对象，作为方法区的访问入口）->连接（验证->准备（分配内存）->解析）->
 *      初始化（执行类构造器方法的过程）
 * 4.java内存模型(JMM java Memory Model): 是一组规则，意在解决在并发编程可能出现的线程安全问。多线程情况下，每个线程都会从主物理内存中读取
 *      数据，拷贝到自己的内存空间（工作内存）进行操作，操作完写回主内存（volatile不保证原子性）
 *      （1）可见性：只要主物理内存被修改就会立即通知其他线程
 *      （2）原子性
 *      （3）有序性
 *
 */
public class JVM内存划分 {
}
