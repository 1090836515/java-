package JVM;

/**
 * 1.内存划分：线程私有：程序计数器，虚拟机栈，本地方法栈；线程共享：堆，方法区，
 *      （1）程序计数器：实现代码的流程控制，记录线程执行的状态，线程切换的时候能继续执行
 *      （2）虚拟机栈：Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分，
 *          Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。存放基本数据类型及对象的引用
 *      （3）本地方法栈：与虚拟机栈类似，区别是为本地方法服务，本地方法保存在动态连接库中，格式是各个平台专用的，非Java代码的接口
 *      （4）堆：存放对象的实例，数组；垃圾回收的主要区域，可以细分为新生代老年代
 *      （5）方法区：存放已被虚拟机加载的类信息、常量、静态变量，也叫永久代
 *      （6）运行时常量池：JDK1.7时在方法区中，1.8之后在堆中；Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息
 *         （用于存放编译期生成的各种字面量和符号引用）
 * 2.String s1 = new String("abc");这句话创建了几个字符串对象？
 *      （1）常量池在编译期确定，首先String不属于8种基本数据类型，String是一个对象；因为对象的默认值是null，所以String的默认值也是null；
 *          但它又是一种特殊的对象，有其它对象没有的一些特性。new String()和new String(“”)都是申明一个新的空字符串，是空串不是null；
 *     （2）将创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，
 *          那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。
 *     （3）String str1 = "abcd";//先检查字符串常量池中有没有"abcd"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，
 *          如果有，则直接将 str1 指向"abcd""；String str3 = "str" + "ing";//常量池中的对象，常量池+常量池必然等于常量池
 *          String str2 = new String("abcd");//堆中创建一个新的对象；String str4 = str1 + str2; //在堆上创建的新的对象
 *     （4）String类型就使用了享元模式.String对象是不变对象，一旦创建出来就不能改变，如果需要改变一个字符串的值，就只 好创建一个新的String对象，
 *          在JVM内部， String对象都是共享的。如果一个系统中有两个String对象所包含的字符串相同的话，JVM实际上只创建一个String对象提供给两个引用，
 *          从 而实现String对象的共享，String的inern()方法给出这个字符串在共享池中的唯一实例.
 * 3.类的加载过程：加载（获取二进制字节流，生成Class对象，作为方法区的访问入口）->连接（验证->准备（分配内存）->解析）->
 *      初始化（执行类构造器方法的过程）
 * 4.java内存模型(JMM java Memory Model): 是一组规则，意在解决在并发编程可能出现的线程安全问题。多线程情况下，每个线程都会从主物理内存中读取
 *      数据，拷贝到自己的内存空间（工作内存）进行操作，操作完写回主内存（volatile不保证原子性）
 *      （1）可见性：只要主物理内存被修改就会立即通知其他线程
 *      （2）原子性
 *      （3）有序性
 * 5.享元模式：String常量池、数据库连接池、缓冲池等等都是享元模式的应用，我们每次创建字符串对象时，都需要创建一个新的字符串对象的话，内存开销会很大，
 *      所以如果第一次创建了字符串对象“adam“，下次再创建相同的字符串”adam“时，只是把它的引用指向”adam“，这样就实现了”adam“字符串再内存中的共享。
 *      何时使用：何时使用；系统中有大量对象时；这些对象消耗大量内存时；这些对象的状态大部分可以外部化时。
 *      优缺点：大大减少了对象的创建，降低了程序内存的占用，提高效率；但提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有固化特性，
 *          不应该随着内部状态的改变而改变。
 *
 */
public class JVM内存划分 {
    public static void main(String[] args) {
        /*String str1 = "abcd";
        String str2 = new String("abc");
        String intern1 = str1.intern();
        String intern2 = str2.intern();
        System.out.println(str1 == intern1);//true
        System.out.println(str2 == intern2);//false*/
    }
}
