package JVM;

/**
 * 1.内存划分：线程私有：程序计数器，虚拟机栈，本地方法栈；线程共享：堆，方法区，
 *      （1）程序计数器：分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成,为了线程切换后能恢复到正确的执行位置，每条线程都需要
 *              有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存，程序计数器是唯一一个不会出现
 *              OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。
 *      （2）虚拟机栈：其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分，存放局部变量及对象的引用。Java 虚拟机栈会出现两种错误：
 *              StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，
 *              就抛出 StackOverFlowError 错误。OutOfMemoryError： Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请
 *              到足够的内存空间，则抛出OutOfMemoryError异常。
 *      （3）本地方法栈：与虚拟机栈类似，区别是为本地方法服务，本地方法保存在动态连接库中，格式是各个平台专用的，非Java代码的接口，也会出现那两个错误
 *      （4）堆：存放对象的实例，数组；垃圾回收的主要区域，可以细分为新生代老年代
 *      （5）方法区：存放已被虚拟机加载的类信息、运行时常量池（字符串常量池除外）、静态变量，也叫永久代，jdk7之后在内存里，叫做元空间
 *      （6）直接内存：直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致
 *              OutOfMemoryError 错误出现。
 *      （7）字符串常量池：JDK1.7时在方法区中，1.8之后在堆中（用于存放编译期生成的各种字面量和符号引用）
 *      (8)基本类型常量池：Integer i = 5;默认调用的是Integer.valueOf()方法，这方法会缓存-127，128之间的数据
 * 2.String s1 = new String("abc");这句话创建了几个字符串对象？
 *      （1）常量池在编译期确定，首先String不属于8种基本数据类型，String是一个对象；因为对象的默认值是null，所以String的默认值也是null；
 *          但它又是一种特殊的对象，有其它对象没有的一些特性。new String()和new String(“”)都是申明一个新的空字符串，是空串不是null；
 *     （2）将创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，
 *          那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。
 *     （3）String str1 = "abcd";//先检查字符串常量池中有没有"abcd"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，
 *          如果有，则直接将 str1 指向"abcd""；String str3 = "str" + "ing";//常量池中的对象，常量池+常量池必然等于常量池
 *          String str2 = new String("abcd");//堆中创建一个新的对象；String str4 = str1 + str2; //在堆上创建的新的对象
 *     （4）String类型就使用了享元模式.String对象是不变对象，一旦创建出来就不能改变，如果需要改变一个字符串的值，就只 好创建一个新的String对象，
 *          在JVM内部， String对象都是共享的。如果一个系统中有两个String对象所包含的字符串相同的话，JVM实际上只创建一个String对象提供给两个引用，
 *          从 而实现String对象的共享，String的inern()方法给出这个字符串在共享池中的唯一实例.
 * 3.类的加载过程：加载（获取二进制字节流，生成Class对象，作为方法区的访问入口）->连接（验证->准备（分配内存）->解析）->
 *      初始化（执行类构造器方法的过程）
 * 4.java内存模型(JMM java Memory Model): 是一组规则，意在解决在并发编程可能出现的线程安全问题。多线程情况下，每个线程都会从主物理内存中读取
 *      数据，拷贝到自己的内存空间（工作内存）进行操作，操作完写回主内存（volatile不保证原子性）
 *      （1）可见性：只要主物理内存被修改就会立即通知其他线程
 *      （2）原子性
 *      （3）有序性
 * 5.享元模式：String常量池、数据库连接池、缓冲池等等都是享元模式的应用，我们每次创建字符串对象时，都需要创建一个新的字符串对象的话，内存开销会很大，
 *      所以如果第一次创建了字符串对象“adam“，下次再创建相同的字符串”adam“时，只是把它的引用指向”adam“，这样就实现了”adam“字符串再内存中的共享。
 *      何时使用：何时使用；系统中有大量对象时；这些对象消耗大量内存时；这些对象的状态大部分可以外部化时。
 *      优缺点：大大减少了对象的创建，降低了程序内存的占用，提高效率；但提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有固化特性，
 *          不应该随着内部状态的改变而改变。
 *
 */
public class JVM内存划分 {
    public static void main(String[] args) {
        /*String str1 = "abcd";
        String str2 = new String("abc");
        String intern1 = str1.intern();
        String intern2 = str2.intern();
        System.out.println(str1 == intern1);//true
        System.out.println(str2 == intern2);//false*/
        int i = 5;
        String j = "50";
        Integer integer = Integer.valueOf(i);
        int i1 = integer.intValue();
        Integer j1 = Integer.valueOf(j);
        int j2 = Integer.parseInt(j);
    }
}
