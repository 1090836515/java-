package 计算机网络;

/**
 * 1.TCP与UDP协议的区别：TCP提供面向连接的服务。在传送数据之前必须先通过三次握手建立连接，数据传送结束后要通过四次挥手释放连接。
 * 2.TCP协议如何保持可靠传输：
 *      （1）校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，
 *              TCP 将丢弃这个报文段和不确认收到此报文段。
 *      （2）流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方
 *              的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）,
 *              接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。
 *      （3）拥塞控制： 当网络拥塞时，会减少数据的发送。为了进行拥塞控制，TCP 发送方要维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决
 *              于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个
 *      （4）ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组
 *      （5）超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
 * 3.在浏览器中输入url地址 ->> 显示主页的过程:DNS解析->TCP连接->发送HTTP请求->服务器处理请求并返回HTTP报文->浏览器解析渲染页面->连接结束
 * 4.三次握手：超时重传
 * 5.四次挥手：当客户端发送FIN报文段请求关闭连接时，服务端的数据可能还没传输完，所以我们需要等待服务端的数据传输完，
 * 8.拥塞控制：
 *      慢开始： 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。
 *              经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一次报文确认，cwnd加倍。
 *      拥塞避免： 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.
 *      快重传与快恢复： 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包，
 *              它要求一旦发现失序的报文段则立即发出重复确认，而不等待自己发送数据的时候才捎带确认。没有 FRR，如果数据包丢失了，TCP 将会使用定时器
 *              来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机
 *              发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为
 *              重传时要求的暂停被耽误。
 * 9.应用程序如何将数据从网卡上面读取到进程当中：
 *      网卡(Network Adapter)，也称网络适配器，是一个硬件设备，有全球唯一的 MAC(Media Access Control)地址，
 *          MAC地址在网卡生产时就被烧制在ROM中，网卡初始化时恢复到计算机中。网卡收到的数据是 光信号或电信号，然后将其还原成 数字信息(1和0组成)。
 *      网卡驱动：就像电脑需要操作系统一样，而网卡驱动就是CPU控制和使用网卡的程序；网卡处理完数字信号后，接下来的数据接收需要CPU参与，此时网卡通过
 *          中断将数据包达到的事件通知给CPU。接着，CPU暂停手头工作，开始用网卡驱动来干活。作用：从网卡缓冲区读取接收到的数据；根据MAC头部的以太类型字段
 *          判断协议种类并调用处理该协议的软件(即协议栈)。
 *      最后，数据就到应用层，应用层通过socket来操作数据。
 *      Socket:socket 译为套接字,对应用层来说，可通过 socket 与内核中的网络协议栈通信。应用不能直接使用协议栈，更不能控制网卡驱动。所以 socket
 *          提供了网络编程的系统调用接口。
 *
 */
public class TCP与UDP {
}
